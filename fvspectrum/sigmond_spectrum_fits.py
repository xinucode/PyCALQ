import logging
import os
import yaml
import pandas as pd
import numpy as np
import h5py
from enum import Enum
from ordered_set import OrderedSet
import general.task_manager as tm
import regex
import tqdm
import time
from multiprocessing import Process

import sigmond
import fvspectrum.spectrum_plotting_settings.settings as psettings
import general.plotting_handler as ph
import fvspectrum.sigmond_util as sigmond_util
from sigmond_scripts import util as utils
from sigmond_scripts import operator
from sigmond_scripts import fit_info, sigmond_info, sigmond_input

doc = '''
fit_spectrum - task for fitting the single hadron and/or rotated correlators in order to determine
    energy spectrum of each channel of interest. If rotated, operator overlaps on the original
    operators are computed and plotted as well.

general:
  ensemble_id: cls21_c103               #required
  ensembles_file: /home/sarahski/latticeQCD/pycalq/pycalq.new_sigmond_task/fvspectrum/sigmond_utils/ensembles.xml #generated by PyCALQ
  project_dir: /latticeQCD/raid3/sarahski/lqcd/C103_R005/test_pycalq_project #required
  sampling_info:                        #not required 
    mode: Jackknife                     #default Jackknife
  tweak_ensemble:                       #not required
    omissions: []                       #default []
    rebin: 1                            #default 1
fit_spectrum:
  default_corr_fit:                     #required unless both default_interacting_corr_fit and default_noninteracting_corr_fit are specified
    model: 1-exp                        #required
    tmin: 15                            #required
    tmax: 25                            #required
    exclude_times: []                   #not required #default []
    initial_params: {}                  #not required #default {}, but if specified, should be a dictionary of param name: value
    noise_cutoff: 0.0                   #not required #default 0
    priors: {}                          #not required #default {}, but if specified, should be a dictionary of param name: value
    ratio: true                         #not required #default false
    sim_fit: false                      #not required #default false 
    tmin_plots:                         #not required #default []
    - model: 1-exp                        #required
      tmin_min: 10                        #required
      tmin_max: 20                        #required
    ...
    tmax_plots:                         #not required #default []
    - model: 1-exp                        #required
      tmax_min: 30                        #required
      tmax_max: 40                        #required
    ...
  reference_particle: pi                #not required #default None
  default_noninteracting_corr_fit: None #not required, but set up is same as default_corr_fit
  default_interacting_corr_fit: None    #not required, but set up is same as default_corr_fit
  correlator_fits:                              #not required #default {}
    operator name:                              #not required, but "operator name" should be replaced with the intended operator 
      tmin: 2                                        #for the fit configuration. Any fit model configuration specified here will
      tmax: 25                                       #override the default
      model: 1-exp 
    ...
  averaged_input_correlators_dir: /some/file    #not required #default is the project directory's average task
  compute_overlaps: true                        #not required #default true
  correlated: true                              #not required #default true
  create_pdfs: true                             #not required #default true
  create_pickles: true                          #not required #default true
  create_summary: true                          #not required #default true
  do_interacting_fits: true                     #not required #default true
  figheight: 6                          #not required #default 6
  figwidth: 8                           #not required #default 8
  only:                                 #not required
  - psq=0
  - isosinglet S=0 E PSQ=3
  ...
  omit:                                 #not required (overridden by 'only' setting)
  - psq=0
  - isosinglet S=0 E PSQ=3
  ...
  generate_estimates: true              #not required #default true
  minimizer_info:                       #not required #defaults below
    chisquare_rel_tol: 0.0001             
    max_iterations: 2000
    minimizer: lmder
    parameter_rel_tol: 1.0e-06
    verbosity: low
  single_hadrons:                       #required for ratio fits. "sh1" and "operator name" should be replaced with
    sh1:                                  #user given single hadron name and relevant operator names in a list ordered by
    - operator name                       #increasing integer momenta
    ...
  single_hadrons_ratio: []              #not required #default [] #set up is like single hadrons, overrides 
                                          #single_hadrons for correlator division for ratio fit (but nothing else)
  non_interacting_levels:               #not required except for ratio fits, needs single_hadrons specified to function
    channel:                          #"channel" should be replaced with channel name
    - [sh1(d1^2), sh2(d1^2)]              #"sh1" and "sh2" should be replaced with single hadron names specified above
    ...                                   #"d1^2" and "d2^2" should be replaced with the integer total momentum of the single hadron
  pivot_file: /some/file                #not required #automatically taken from project if not given
  plot: true                            #not required #default true
  precompute: true                      #not required #default true
  rotated_input_correlators_dir:        #not required #automatically taken from project if not given
  run_tag: ""                           #not required #default "" 
  rotate_run_tag: ""                    #not required #default "" #should correspond to rotate run_tag
  thresholds:                           #not required #default [] #replace "sh1" and "sh2" with user given names
  - [sh1, sh2]
  ...
  use_rotated_samplings: true            #not required #default true => broken
  used_averaged_bins: true               #not required #default true
  tN: 5                                 #not required #defualt finds most recently used file
  t0: 5                                 #not required #defualt finds most recently used file
  tD: 10                                #not required #defualt finds most recently used file
  pivot_type: 0                         #not required #defualt finds most recently used file; 0 - single pivot, 1 - rolling pivot
'''

#for guessing number of hadrons in an operator
hadron_names = ['N', 'X', 'k', 'S', 'L', 'pi', 'P', 'K'] #common names for fundamental hadrons
hadron_tags = ['(',"-","["] #common tags used to associate irreps to the common names

#use the above lists to guess number of hadrons in an operator
def count_hadrons(opname): #based on the "name" piece of an operator (the part that is user define)
    temp_opname = opname
    count = 0
    for hadron in hadron_names:
        for tag in hadron_tags:
            count += temp_opname.count(hadron+tag)
            temp_opname.replace(hadron+tag,"")
    return count

#sort a set of levels (list of dicts) by key "ecm value"
def energy_sort(item): #sort a list oject of dictionaries by the dictionary key "ecm value"
    return item["ecm value"]

#sort a list of lists by the sorting_index element of the list element 
    #by first setting the variable sorting_index  with table_sort_set and then using 
    #table sort for the sorting
sorting_index = [3]
def table_sort_set(index): 
    sorting_index[0] = index
    return table_sort
def table_sort(item): #sort a list of lists by fourth element
    return item[sorting_index[0]]

class Obs(Enum): #relevant obs shortnames
    dElab = 0 #shift energy
    elab = 1 #energy in lab frame
    ecm = 2 #energy in center of momentum frame
    ecm_ref = 3 #energy in center of momentum from divided by single hadron mass
    amp = 4 #amplitude, assumed lab frame

#to do: 
#have user input how the shifts are calculated
#mpi
#add other task types (different NI levels, rebin analysis, compare spectrums, )

class SigmondSpectrumFits:
    @property
    def info(self): 
        return doc
        
    #from the used defined list of single hadrons
    def get_single_hadron(self, corr):
        for hadron in self.other_params['single_hadrons']:
            if corr in self.other_params['single_hadrons'][hadron]:
                return hadron, self.other_params['single_hadrons'][hadron].index(corr)
        return None, None
    
    #get operator object from string formatted as sh(d^2); for example N(0)
    def get_sh_operator(self, sh_string):
        return operator.Operator(self.other_params['single_hadrons'][sh_string.split('(')[0]][int(sh_string.split('(')[1][:-1])])
    
    #sigmond logs of chosen fits
    def fit_log_file(self, op):
        return os.path.join(self.proj_files_handler.log_dir("fit_logs"), f"{str(op).replace(' ','_')}_fit_log.xml")
    
    #configures the directory of potential outputs
    def samplings_file(self, filetag, channel=None):
        if self.project_handler.project_info.sampling_info.isJackknifeMode():
            sampling_mode = 'J'
        else:
            sampling_mode = 'B'
        rotate_type = 'SP'
        if self.other_params['pivot_type']:
            rotate_type = 'RP'
        if self.other_params['run_tag']:
            filetag+= '-'+self.other_params['run_tag']
        return self.proj_files_handler.samplings_file(False, channel, None, 
                                                     self.project_handler.project_info.bins_info.getRebinFactor(),
                                                     sampling_mode, rotate_type, self.tN, self.t0, self.tD, filetag)

        
    #filename for file output with the parameter fit samplings  of the interacting correlator fits 
        #in sigmond hdf5 format with naming scheme based on sigmond scripts
    def spectrum_fit_params_file( self, channel = None ): #add rotation info, and then average info
        return self.samplings_file("fitparams", channel)
        
    #filename for file output with samplings of the energy levels from the chosen fits
    def spectrum_levels_file( self, channel = None ): #add rotation info, and then average info
        return self.samplings_file("levels", channel)
        
    #filename for file output with the parameter fit samplings  of the noninteracting correlator fits 
        #in sigmond hdf5 format with naming scheme based on sigmond scripts
    def single_hadron_fit_params_file( self, channel = None):
        if self.project_handler.project_info.sampling_info.isJackknifeMode():
            sampling_mode = 'J'
        else:
            sampling_mode = 'B'
        run_tag = ''
        if self.other_params['run_tag']:
            run_tag='-'+self.other_params['run_tag']
        return self.proj_files_handler.samplings_file(False, channel, None, 
                                                     self.project_handler.project_info.bins_info.getRebinFactor(),
                                                     sampling_mode, None, None, None, None, "sh_fitparams"+run_tag)
        
    #estimates of spectrum chosen fits filename
    @property
    def spectrum_fit_estimates( self):
        file_tag=''
        if self.other_params['run_tag']:
            file_tag='-'+self.other_params['run_tag']
        rebin = self.project_handler.project_info.bins_info.getRebinFactor()
        if self.project_handler.project_info.sampling_info.isJackknifeMode():
            sampling_mode = 'J-samplings'
        else:
            sampling_mode = 'B-samplings'
        rotate_type = 'SP'
        if self.other_params['pivot_type']:
            rotate_type = 'RP'
        basename = self.proj_files_handler.filekey(None, rebin, sampling_mode, rotate_type, self.tN, self.t0, self.tD, file_tag)
        return self.proj_files_handler.estimates_file(basename)
    
    #estimates of spectrum fit variations filename
    @property
    def spectrum_tmin_estimates( self):
        return self.proj_files_handler.estimates_file("tmin")
    
    #samplings file of operator overlaps
    def operator_overlaps_samplings(self, channel = None):
        if self.project_handler.project_info.sampling_info.isJackknifeMode():
            sampling_mode = 'J'
        else:
            sampling_mode = 'B'
        rotate_type = 'SP'
        if self.other_params['pivot_type']:
            rotate_type = 'RP'
        return self.proj_files_handler.operator_overlaps_samplings(channel, self.project_handler.project_info.bins_info.getRebinFactor(),
                                                     sampling_mode, rotate_type, self.tN, self.t0, self.tD, self.other_params["run_tag"])

    def __init__( self, task_name, proj_files_handler, general_configs, task_configs, sph ):
        self.task_name = task_name
        self.proj_files_handler= proj_files_handler
        self.project_handler = sph

        #set up sigmond necessities
        self.ensemble_info = sigmond_util.get_ensemble_info(general_configs)

        #define default fit params for anything other than tmin, tmax, and model
        self.default_fit_params = {
            'ratio': False,
            'exclude_times': [],
            'noise_cutoff': 0.0,
            'non_interacting_operators': None, #only desired for ratio or conspiracy fits
            'sim_fit': False, 
            'initial_params': {},
            'priors': {},
            'tmin_plots': [],
            'tmax_plots': [],
            'tmin_try_min': None,
            'tmin_try_max': None,
        }

        #other params
        self.other_params = {
            'create_pdfs': True,
            'create_pickles': True,
            'create_summary': True,
            'plot': True,
            'figwidth':8,
            'figheight':6,
            'generate_estimates': True,
            'used_averaged_bins': True, #otherwise, use samplings
            'use_rotated_samplings': True, #otherwise, use bins
            'precompute': True,
            'correlated': True,
            'minimizer_info': {
                'minimizer':'lmder',
                'parameter_rel_tol': 1e-6,
                'chisquare_rel_tol': 1e-4,
                'max_iterations': 2000,
                'verbosity': 'high',
            },
            'correlator_fits': [],
            'single_hadrons': {},
            'single_hadrons_ratio': {},
            'non_interacting_levels': {},
            'reference_particle': None,
            'thresholds': [],
            'compute_overlaps': True,
            'pivot_file': None,
            'rotate_run_tag': "",
            'run_tag': "",
            'pivot_type': "*", #0 - single; 1 - rolling
            'do_interacting_fits': True
        }
        sigmond_util.update_params(self.other_params,task_configs) #update other_params with task_params, 
                                                                        #otherwise fill in missing task params
        
        #checks to make sure that default fits have been chosen for all fits
        if 'default_corr_fit' not in task_configs and ('default_noninteracting_corr_fit' not in task_configs or 'default_noninteracting_corr_fit' not in task_configs):
            logging.error("Must specify a 'default_corr_fit' or 'default_noninteracting_corr_fit' and 'default_noninteracting_corr_fit' in task configs.")

        #sets up default fits
        if 'default_interacting_corr_fit' in task_configs and 'default_noninteracting_corr_fit' in task_configs:
            self.default_interacting_corr_fit = task_configs['default_interacting_corr_fit']
            self.default_noninteracting_corr_fit = task_configs['default_noninteracting_corr_fit']
            self.check_fit_inputs(self.default_interacting_corr_fit, task_configs, 'default_interacting_corr_fit')
            self.check_fit_inputs(self.default_noninteracting_corr_fit, task_configs, 'default_noninteracting_corr_fit')
            self.default_corr_fit = None
        else:
            self.default_interacting_corr_fit = None
            self.default_noninteracting_corr_fit = None
            self.default_corr_fit = task_configs['default_corr_fit']
            self.check_fit_inputs(self.default_corr_fit, task_configs, 'default_corr_fit')

        #get pivot information if given, otherwise will search for the most recently computed gevp in the project
            #or if the file is given, just use that
        self.tN = task_configs.pop('tN',"*")
        self.t0 = task_configs.pop('t0',"*")
        self.tD = task_configs.pop('tD',"*")
            
        #set up the filetag for sampling type
        if self.project_handler.project_info.sampling_info.isJackknifeMode(): #do this better
            sampling_mode = 'J'
        else:
            sampling_mode = 'B'

        #use datafiles that were input, otherwise search this project
        averaged_data_files = []
        if 'averaged_input_correlators_dir' in task_configs:
            if type(task_configs['averaged_input_correlators_dir'])==list:
                averaged_data_files=task_configs['averaged_input_correlators_dir']
            else:
                averaged_data_files.append(task_configs['averaged_input_correlators_dir'])
        else:
            averaged_data_files = self.proj_files_handler.get_averaged_data(self.other_params['used_averaged_bins'],
                                                                           self.project_handler.project_info.bins_info.getRebinFactor(),
                                                                           sampling_mode)
        #add datafiles to data handler object
        self.project_handler.add_averaged_data(averaged_data_files)

        if self.other_params['do_interacting_fits']:
            #set up filetag for single pivot vs rolling pivot
            rotate_type = self.other_params['pivot_type']
            if self.other_params['pivot_type']!="*":
                rotate_type = 'SP'
                if self.other_params['pivot_type']:
                    rotate_type = 'RP'
                
            #use datafiles that were input, otherwise search this project
            rotated_data_files = []
            if 'rotated_input_correlators_dir' in task_configs:
                if type(task_configs['rotated_input_correlators_dir'])==list:
                    rotated_data_files=task_configs['rotated_input_correlators_dir']
                else:
                    rotated_data_files.append(task_configs['rotated_input_correlators_dir'])
                    
            else:
                #if not given, use the given gevp info to find the most recent file that matches the given info in the project
                rotated_data_files = self.proj_files_handler.get_rotated_data(not self.other_params['use_rotated_samplings'],
                                                                            self.project_handler.project_info.bins_info.getRebinFactor(), #sigmond_util.get_selected_mom(task_configs),
                                                                            rotate_type, self.tN, self.t0, self.tD, sampling_mode, self.other_params['rotate_run_tag'])
                rotated_data_files.sort(key=os.path.getmtime)
                rotated_data_files = [rotated_data_files[-1]]

                pattern= self.proj_files_handler.all_tasks[tm.Task.rotate_corrs.name].samplings_file(not self.other_params['use_rotated_samplings'], 
                                                        None, None, self.project_handler.project_info.bins_info.getRebinFactor(),sampling_mode, 
                                                        "(?<pivot>\S+)", "(?<tN>[0-9]+)", "(?<t0>[0-9]+)", "(?<tD>[0-9]+)", self.other_params['rotate_run_tag'])
                match = regex.search(pattern, rotated_data_files[0])
                if match:
                    match = match.groupdict()
                    self.tN = match['tN']
                    self.t0 = match['t0']
                    self.tD = match['tD']
                    if match['pivot']=='SP':
                        self.other_params['pivot_type']=0
                    elif match['pivot']=='RP':
                        self.other_params['pivot_type']=1
                    task_configs['tN'] = self.tN
                    task_configs['t0'] = self.t0
                    task_configs['tD'] = self.tD
                    task_configs['pivot_type'] = self.other_params['pivot_type']

            if self.other_params['pivot_type']=='*' or self.tN=='*' or self.t0=='*' or self.tD=='*':
                        logging.critical(f"Could not find the appropriate rotate file '{rotated_data_files[0]}'.")

            #set up filetag for single pivot vs rolling pivot
            rotate_type = 'SP'
            if self.other_params['pivot_type']:
                rotate_type = 'RP'
            
            #add datafiles to data handler object
            self.project_handler.add_rotated_data(rotated_data_files)

            #get pivot file if one if not given -> need to fix for multiple rotations
            if self.other_params["pivot_file"]==None: #
                self.other_params["pivot_file"] = self.proj_files_handler.pivot_file(rotate_type, self.tN, self.t0, self.tD, self.other_params['rotate_run_tag'],
                                                                                    self.project_handler.project_info.bins_info.getRebinFactor(),
                                                                                    sampling_mode)
                task_configs["pivot_file"] = self.other_params["pivot_file"]
                
        #get single hadron channels in a list
        self.single_hadron_channels = []
        for sh in self.other_params['single_hadrons']:
            for op in self.other_params['single_hadrons'][sh]:
                self.single_hadron_channels.append(operator.Operator(op).channel)

        #get channels from data handler
        self.data_handler = self.project_handler.data_handler
        self.achannels = self.data_handler.averaged_channels[:]
        self.rchannels = self.data_handler.rotated_channels[:]

        #select channels specified by user #remove unwanted channels
        final_channels = sigmond_util.filter_channels( task_configs, self.rchannels)
        remove_channels = list(set(self.rchannels)-set(final_channels))
        self.project_handler.remove_rotated_data_channels(remove_channels)
        self.rchannels = final_channels

        #select unqualified channels
        rm_channels = []
        for channel in self.achannels: #remove interacting operators that need to be rotated
            num_hadrons = 0
            if self.data_handler.getAveragedOperators(channel)[0].operator_info.isGenIrrep():
                opname = self.data_handler.getAveragedOperators(channel)[0].operator_info.getGenIrrep().getIDName()
                num_hadrons = count_hadrons(opname)
            else: 
                num_hadrons = self.data_handler.getAveragedOperators(channel)[0].operator_info.getBasicLapH().getNumberOfHadrons()

            if len(self.data_handler.getAveragedOperators(channel))>1 and num_hadrons>1:
                rm_channels.append(channel)
            elif num_hadrons>1:
                # rm_channels.append(channel)
                self.rchannels.append(channel)
            elif num_hadrons==1:
                if channel not in self.single_hadron_channels:
                    rm_channels.append(channel)

        #remove undesired or unqualified channels
        self.project_handler.remove_averaged_data_channels(rm_channels)
        self.achannels = list(set(self.achannels)-set(rm_channels))

        #remove single operator channels that were just added to "rotated" channels in if not desired.
        final_channels = sigmond_util.filter_channels( task_configs, self.rchannels)
        remove_channels = list(set(self.rchannels)-set(final_channels))
        self.project_handler.remove_averaged_data_channels(remove_channels)
        self.rchannels = final_channels

        #log final channel set
        task_configs['fitted_channels'] = []
        for channel in self.achannels+self.rchannels:
            task_configs['fitted_channels'].append(str(channel))

        #get data files
        self.data_files = self.data_handler.averaged_data_files
        self.data_files += self.data_handler.rotated_data_files 

        #if no plots requested will not plot
        if not self.other_params['create_pdfs'] and not self.other_params['create_pickles'] and not self.other_params['create_summary']:
            self.other_params['plot'] = False

        # print(self.ensemble_info.getLatticeXExtent())
        
        #make yaml output
        logging.info(f"Full input written to '{os.path.join(proj_files_handler.log_dir(), 'full_input.yml')}'.")
        with open( os.path.join(proj_files_handler.log_dir(), 'full_input.yml'), 'w+') as log_file:
            yaml.dump({"general":general_configs, task_name: task_configs}, log_file)

    def run( self ):
        #get sigmond memory handler
        self.mcobs_handler, self.mcobs_get_handler = sigmond_util.get_mcobs_handlers(self.data_handler,self.project_handler.project_info)
        
        #set correlated or uncorrelated fits
        if self.other_params['correlated']:
            self.mcobs_handler.setToCorrelated()
        else:
            self.mcobs_handler.setToUnCorrelated()

        #single hadron fits, write results to hdf5 as we go
        self.single_hadron_results = {}
        self.single_hadron_info = {}
        single_hadron_operators = {}
        self.results = {}
        self.tmin_results = {}
        self.tmax_results = {}
        file_created = False
        sh_levels_written = False
        with h5py.File(self.spectrum_levels_file(),'w') as final_levels:
            sh_levels = final_levels.create_group('single_hadrons')
            for channel in self.single_hadron_channels: #achannels+self.rchannels:
                self.single_hadron_results[channel] = {}
                self.tmin_results[channel] = {}
                self.tmax_results[channel] = {}
                operators = self.data_handler.getChannelOperators(channel)
                if len(operators):

                    #determine if it is a good channel #move to set up?
                    op = operators[0]
                    if len(operators)==1:
                        intop = op
                    else:
                        intop = operator.Operator( channel.getRotatedOp(0) )
                    if op.operator_info.isBasicLapH():
                        hadrons = op.operator_info.getBasicLapH().getNumberOfHadrons()
                    else:
                        opname = op.operator_info.getGenIrrep().getIDName()
                        hadrons = count_hadrons(opname) 
                    single_hadron, _ = self.get_single_hadron(str(intop))

                    if single_hadron and hadrons>1:
                        logging.error(f"Interacting correlator '{intop}' in single_hadrons list.")
                    elif single_hadron:
                        mom = channel.psq #instead of list index, use the channel mom^2
                        # if mom==0:
                        logging.info(f"Fitting channel '{str(channel)}'...")
                        for i,op in enumerate(operators):
                            
                            #set up single hadron fit
                            if file_created:
                                wmode = sigmond.WriteMode.Update
                            else:
                                wmode = sigmond.WriteMode.Overwrite
                            if len(operators)==1:
                                intop = op
                            else:
                                intop = operator.Operator( channel.getRotatedOp(i) )
                            single_hadron, sh_list_index = self.get_single_hadron(str(intop))
                            hadron_string = f"{single_hadron}({mom})"

                            if single_hadron in self.other_params['single_hadrons_ratio']:
                                single_hadron_operators[sigmond_info.ScatteringParticle.create(hadron_string)] = operator.Operator(self.other_params['single_hadrons_ratio'][single_hadron][sh_list_index])
                            else:
                                single_hadron_operators[sigmond_info.ScatteringParticle.create(hadron_string)] = operator.Operator(self.other_params['single_hadrons'][single_hadron][sh_list_index])
                            self.single_hadron_info[f"{single_hadron}({mom})"] = {}
                            self.single_hadron_info[f"{single_hadron}({mom})"]["mom"] = mom

                            # if mom==0:
                            logging.info(f"\tFitting operator '{str(intop)}'...")
                            if self.default_noninteracting_corr_fit:
                                this_fit_input = dict(self.default_noninteracting_corr_fit)
                            else:
                                this_fit_input = dict(self.default_corr_fit)
                            if str(intop) in self.other_params['correlator_fits']:
                                for param, setting in self.other_params['correlator_fits'][str(intop)].items():
                                    this_fit_input[param] = setting
                                if 'model' in self.other_params['correlator_fits'][str(intop)]:
                                    this_fit_input['model'] = fit_info.FitModel(this_fit_input['model'])
                                    
                            file = self.single_hadron_fit_params_file(repr(channel))
                            #do the fit, results stored in self.single_hadron_results and self.tmin_results
                            self.single_hadron_info[hadron_string]["energy_obs"], self.single_hadron_info[hadron_string]["amp_obs"] = self.do_fits( self.single_hadron_results, channel, intop, 
                                                                                                                                                this_fit_input, wmode, file, hadrons, self.tmin_results, 
                                                                                                                                                self.tmax_results)
                            file_created = True
                            
                            #record important info
                            if self.single_hadron_results[channel][intop]["success"]:
                                self.single_hadron_info[hadron_string]["ecm"] = self.single_hadron_results[channel][intop]["ecm"].getFullEstimate()
                                self.single_hadron_info[hadron_string]["ecm_ref"] = self.single_hadron_results[channel][intop]["ecm"].getFullEstimate()

                                #if successful fit, add to hdf5
                                samplings = self.mcobs_handler.getFullAndSamplingValues(self.single_hadron_info[hadron_string]["energy_obs"], 
                                                                                self.project_handler.project_info.sampling_info.getSamplingMode())
                                sh_levels.create_dataset(hadron_string,data=np.array(samplings.array()))
                                sh_levels_written = True

        logging.info(f"Fit parameters written to {self.single_hadron_fit_params_file()}.")
        if sh_levels_written:
            logging.info(f"Single hadron masses written to {self.spectrum_levels_file()}.")

        #spectrum fits
        self.interacting_channels = []
        if self.other_params['do_interacting_fits']:
            # threads = []
            # thread_index = 0
            file_created = False
            logging.info(f"Fitting spectrum...")
            for channel in self.rchannels:
                self.results[channel] = {}
                operators = self.data_handler.getChannelOperators2(channel) #collects rotated operators first
                #determine if its a good channel
                if len(operators):
                    op = operators[0]
                    if op.operator_info.isBasicLapH():
                        hadrons = op.operator_info.getBasicLapH().getNumberOfHadrons()
                    else:
                        opname = op.operator_info.getGenIrrep().getIDName()
                        if "ROT" in opname:
                            hadrons=2
                        else:
                            hadrons = count_hadrons(opname) #make table of all single hadrons? or use parenthesis or dashes

                    if len(operators)==1:
                        intop = op
                    else:
                        intop = operator.Operator( channel.getRotatedOp(0) )

                    single_hadron, _ = self.get_single_hadron(str(intop))
                    if (not single_hadron and hadrons>=2) or (not single_hadron and len(operators)>=2):
                        if channel not in self.tmin_results.keys():
                            self.tmin_results[channel] = {}
                        if channel not in self.tmax_results.keys():
                            self.tmax_results[channel] = {}
                        self.interacting_channels.append(channel)
                        logging.info(f"Fitting channel '{str(channel)}'...")
                        for i,op in enumerate(operators):

                            #set up fit
                            if file_created:
                                wmode = sigmond.WriteMode.Update
                            else:
                                wmode = sigmond.WriteMode.Overwrite

                            if len(operators)==1:
                                intop = op
                            else:
                                intop = operator.Operator( channel.getRotatedOp(i) )
                            logging.info(f"\tFitting operator '{str(intop)}'...")

                            if self.default_interacting_corr_fit:
                                this_fit_input = dict(self.default_interacting_corr_fit)
                            else:
                                this_fit_input = dict(self.default_corr_fit)

                            if str(intop) in self.other_params['correlator_fits']:
                                for param, setting in self.other_params['correlator_fits'][str(intop)].items():
                                    this_fit_input[param] = setting

                            #set up ratio fits   
                            if str(channel) in self.other_params['non_interacting_levels']:
                                if len(self.other_params['non_interacting_levels'][str(channel)])<i:
                                    logging.warning(f"Non enough non-interacting levels defined for channel {str(channel)}.")
                                    continue
                                non_interacting_level = self.other_params['non_interacting_levels'][str(channel)][i]
                            else:
                                non_interacting_level = None

                            if non_interacting_level:
                                try:
                                    non_interacting_ops = sigmond_info.NonInteractingOperators.create(single_hadron_operators,non_interacting_level)
                                    this_fit_input["non_interacting_operators"] = non_interacting_ops

                                    #add as ability of choosing between direct fits or ground state for NI level shift calculation
                                    non_interacting_level = [(self.single_hadron_info[particle.replace(str(self.single_hadron_info[particle]["mom"]),'0')]["energy_obs"],self.single_hadron_info[particle]["mom"]) for particle in non_interacting_level]

                                    this_fit_input["non_interacting_level"] = non_interacting_level
                                except RuntimeError as err:
                                    continue

                            file = self.spectrum_fit_params_file(channel)
                            self.do_fits( self.results, channel, intop, this_fit_input, wmode, file, hadrons, self.tmin_results, self.tmax_results)
                            if self.results[channel][intop]["success"]:
                                file_created = True

            logging.info(f"All fit parameters written to {self.spectrum_fit_params_file()}.")
            logging.info(f"Log files written to {self.proj_files_handler.log_dir('fit_logs')}.")

        #divide single hadron ecm by ref for plotting info
        if f"{self.other_params['reference_particle']}(0)" in self.single_hadron_info:
            ref_ecm = self.single_hadron_info[f"{self.other_params['reference_particle']}(0)"]["ecm"]
            for particle in self.single_hadron_info:
                if "ecm_ref" in self.single_hadron_info[particle]:
                    self.single_hadron_info[particle]["ecm_ref"] /= ref_ecm
                
        #compute overlaps
        if self.other_params['do_interacting_fits'] or self.interacting_channels:
            self.zmags = {}
            if self.other_params["compute_overlaps"]:
                logging.info(f"Computing overlaps...")
                any_success = False
                pivot_type = sigmond_util.get_pivot_type(self.other_params["pivot_file"])
                if pivot_type==None:
                    logging.warning("Given file for pivot is not a pivot type. Skipping operator overlap calculation")
                    self.other_params["compute_overlaps"] = False

                if self.other_params["compute_overlaps"]:
                    reorder = True

                    file_created = False
                    for channel in tqdm.tqdm(self.interacting_channels):
                        success = False
                        if len(self.results[channel])>=2:
                            for op in self.results[channel]:
                                success = self.results[channel][op]["success"]
                                if not success:
                                    break
                        if not success:
                            logging.warning(f"Not enough fits in channel {channel}; cannot compute overlaps.")
                            continue
                        
                        any_success = True
                        if file_created:
                            wmode = sigmond.WriteMode.Update
                        else:
                            wmode = sigmond.WriteMode.Overwrite

                        self.zmags[channel] = {}
                        pivoter = sigmond_util.setup_pivoter(pivot_type, self.other_params["pivot_file"], channel, self.mcobs_handler)

                        #give the pivoter the fit information
                        for op in self.results[channel]:
                            this_fit_info = self.results[channel][op]["info"]
                            elab_obs_info = this_fit_info.fit_param_obs(this_fit_info.num_params+Obs.elab.value)
                            amp_obs_info = this_fit_info.fit_param_obs(this_fit_info.num_params+Obs.amp.value)
                            pivoter.insertEnergyFitInfo(op.level, elab_obs_info)
                            pivoter.insertAmplitudeFitInfo(op.level, amp_obs_info)

                        if reorder:
                            loghelper = sigmond.LogHelper()
                            pivoter.reorderLevelsByFitEnergy(loghelper)

                        zmags = pivoter.computeZMagnitudesSquaredPython(self.operator_overlaps_samplings(repr(channel)),wmode,'H',f"{repr(channel)}-")
                        file_created = True
                        self.zmags[channel]["ops"] = pivoter.getOperatorsPython()
                        self.zmags[channel]["nlevels"] = pivoter.getNumberOfLevels()
                        self.zmags[channel]["zmags"] = zmags

                    if any_success:   
                        logging.info(f"Operator overlaps written to {self.operator_overlaps_samplings()}.")
                    else:
                        self.other_params["compute_overlaps"] = False

                
        #add to spectrum level with single hadron levels in the spectrum hdf5, delete interacting samplings after finish
        logging.info("Writing spectrum level samplings to file...")
        with h5py.File(self.spectrum_levels_file(False),'a') as final_levels:
            if self.other_params['reference_particle']:
                ref_obs = self.single_hadron_info[f"{self.other_params['reference_particle']}(0)"]["energy_obs"]
                ref_channel =  operator.Operator(self.other_params['single_hadrons'][self.other_params['reference_particle']][0]).channel
            for channel in tqdm.tqdm(self.results):
                if self.results[channel]:
                    strangeness = channel.strangeness
                    if strangeness<0:
                        strange_key = f"m{-strangeness}"
                    else:
                        strange_key = strangeness
                    particle_str = f"iso{channel.isospin}_S{strange_key}"
                    if particle_str in final_levels.keys():
                        particle_group = final_levels[particle_str]
                    else:
                        particle_group = final_levels.create_group(particle_str)

                    mom = channel.mom_str
                    #check if mom_group exists
                    if mom in particle_group.keys():
                        mom_group = particle_group[mom]
                    else:
                        mom_group = particle_group.create_group(mom)
                    irrep_group =  mom_group.create_group(channel.irrep)
                    level_ordering = []
                    complete_basis = True
                    for op in self.results[channel]:
                        if self.results[channel][op]["success"]:
                            this_fit_info = self.results[channel][op]["info"]
                            delab_obs_info = sigmond.MCObsInfo(this_fit_info.obs_name, this_fit_info.obs_id(this_fit_info.num_params+Obs.dElab.value))
                            elab_obs_info = sigmond.MCObsInfo(this_fit_info.obs_name, this_fit_info.obs_id(this_fit_info.num_params+Obs.elab.value))
                            ecm_obs_info = sigmond.MCObsInfo(this_fit_info.obs_name, this_fit_info.obs_id(this_fit_info.num_params+Obs.ecm.value))
                            ecmref_obs_info = sigmond.MCObsInfo(this_fit_info.obs_name, this_fit_info.obs_id(this_fit_info.num_params+Obs.ecm_ref.value))
                            if self.mcobs_handler.queryFullAndSamplings(elab_obs_info):
                                self.mcobs_handler.setSamplingBegin()
                                this_level = {
                                    "rotate_level": op.level, 
                                    "ecm value": self.mcobs_handler.getCurrentSamplingValue(elab_obs_info),
                                    "elab": elab_obs_info,
                                }
                                if "dElab" in self.results[channel][op]:
                                    this_level["dElab"] = delab_obs_info
                                if channel.psq:
                                    this_level["ecm"] = ecm_obs_info
                                    if self.other_params['reference_particle']:
                                        sigmond.doRatioBySamplings(self.mcobs_handler, ecm_obs_info, ref_obs, ecmref_obs_info)
                                else:
                                    this_level["ecm"] = elab_obs_info
                                    if self.other_params['reference_particle']:
                                        sigmond.doRatioBySamplings(self.mcobs_handler, elab_obs_info, ref_obs, ecmref_obs_info)
                                if self.other_params['reference_particle']:
                                    this_level["ecm_ref"] = ecmref_obs_info
                                
                                level_ordering.append(this_level)
                                if self.other_params['reference_particle']:
                                    self.results[channel][op]["ecm_ref"] = self.mcobs_handler.getEstimate(ecmref_obs_info)
                            else:
                                complete_basis = False
                        else:
                            complete_basis = False
                    
                    if complete_basis:
                        level_ordering.sort(key=energy_sort)
                        free_levels = [self.other_params['non_interacting_levels'][str(channel)][level["rotate_level"]] for level in level_ordering]
                        # free_levels = [[[particle.split('(')[0],particle.split('(')[1][:-1]] for particle in level] for level in free_levels]
                        # print(channel, free_levels)
                        irrep_group.attrs['free_levels'] = free_levels

                    for i, level in enumerate(level_ordering):
                        for energy in ["ecm", "elab", 'dElab','ecm_ref']:
                            if energy in level:
                                samplings = self.mcobs_handler.getFullAndSamplingValues(level[energy], 
                                                self.project_handler.project_info.sampling_info.getSamplingMode())
                                
                                if complete_basis:
                                    energy_index = i
                                else:
                                    energy_index = level['rotate_level']
                                if '_ref' in energy:
                                    energy_name = f"{energy.replace('_ref','')}_{energy_index}_ref"
                                else:
                                    energy_name = f"{energy}_{energy_index}"
                                irrep_group.create_dataset(energy_name,data=np.array(samplings.array()))
                        for energy in ["ecm", "elab", 'dElab','ecm_ref']:
                            if energy in level:
                                if self.mcobs_handler.queryFullAndSamplings(level[energy]):
                                    if self.other_params['reference_particle']:
                                        if ref_channel!=channel:
                                            self.mcobs_handler.eraseSamplings(level[energy])

            # divide single hadrons by reference particle
            if self.other_params['reference_particle']:
                if f"{self.other_params['reference_particle']}(0)" in self.single_hadron_info:
                    reference_samplings = final_levels['single_hadrons'][f"{self.other_params['reference_particle']}(0)"][()]
                    final_levels['single_hadrons'].create_dataset("ref",data=(reference_samplings))
                    for particle in final_levels['single_hadrons'].keys():
                        samplings = final_levels['single_hadrons'][particle][()]
                        final_levels['single_hadrons'].create_dataset(particle+"_ref",data=(samplings/reference_samplings))


                else:
                    logging.warning(f"Reference particle {self.other_params['reference_particle']}(0) not defined.")
        
        if os.path.exists(self.spectrum_levels_file()):
            logging.info(f"Final level samplings written to {self.spectrum_levels_file()}.")

        if self.other_params['do_interacting_fits'] or self.interacting_channels:
            #add rotation and ensemble info to all sampling output files
            with h5py.File(self.other_params["pivot_file"]) as pivotfile:
                rotate_info = pivotfile['Info']['Header'][()]
                if os.path.exists(self.spectrum_fit_params_file()):
                    with h5py.File(self.spectrum_fit_params_file(), 'r+') as paramsfile:
                        paramsfile['Info'].create_dataset('Header', data = rotate_info)
                if self.other_params["compute_overlaps"]:
                    with h5py.File(self.operator_overlaps_samplings(), 'r+') as overlapsfile:
                        overlapsfile['Info'].create_dataset('Header', data = rotate_info)
                if os.path.exists(self.spectrum_levels_file()):
                    with h5py.File(self.spectrum_levels_file(), 'r+') as levelsfile:
                        levelsinfo = levelsfile.create_group('Info')
                        levelsinfo.create_dataset('Header', data = rotate_info)

        #write estimates of both single hadrons and spectrum #separate into different files or specify sh or interacting, occasionally they have the same channel name. 
        if self.other_params["generate_estimates"]:
            logging.info("Writing estimates to file...")
            out_results = []
            for channel in self.rchannels+self.single_hadron_channels:
                channel_results = []
                complete_channel = True
                all_results = {}
                if channel in self.results:
                    all_results.update(self.results[channel])
                if channel in self.single_hadron_results:
                    all_results.update(self.single_hadron_results[channel])
                for i,op in enumerate(all_results):
                    if all_results[op]["success"]:
                        if op.operator_info.isGenIrrep():
                            irrep = op.operator_info.getGenIrrep().getLGIrrep()
                        else:
                            irrep = op.operator_info.getBasicLapH().getLGIrrep()
                        simple_result = {
                            "isospin": channel.isospin,
                            "strangeness": channel.strangeness,
                            "irrep": irrep,
                            "momentum": op.psq,
                            "rotate level": op.level,
                            "model": all_results[op]["info"].model.short_name,
                            "ratio": all_results[op]["info"].ratio,
                            "tmin": all_results[op]["info"].tmin,
                            "tmax": all_results[op]["info"].tmax,
                            "chisqrdof": all_results[op]["chisqrdof"],
                            "qual": all_results[op]["qual"],
                            "dof": all_results[op]["dof"],
                            "ecm value": all_results[op]["ecm"].getFullEstimate(),
                            "ecm error": all_results[op]["ecm"].getSymmetricError(),
                        }
                        if "dElab" in all_results[op]:
                            simple_result["dElab value"] = all_results[op]["dElab"].getFullEstimate()
                            simple_result["dElab error"] = all_results[op]["dElab"].getSymmetricError()
                            simple_result["non-interacting level"] = self.other_params['non_interacting_levels'][str(channel)][i]
                        if "ecm_ref" in all_results[op]:
                            simple_result["ecm_ref value"] = all_results[op]["ecm_ref"].getFullEstimate()
                            simple_result["ecm_ref error"] = all_results[op]["ecm_ref"].getSymmetricError()
                        channel_results.append(simple_result)
                    else:
                        complete_channel = False
                if complete_channel:
                    channel_results.sort(key=energy_sort)
                    [item.update({"fit level": i}) for i, item in enumerate(channel_results)]
                out_results += channel_results
            df = pd.DataFrame.from_dict(out_results)
            df.to_csv(self.spectrum_fit_estimates, index=False, header=True)
            logging.info(f"Wrote final fit estimates to file {self.spectrum_fit_estimates}.")

            #and the tmin estimates now
            out_results = []
            for channel in self.single_hadron_channels+self.interacting_channels:
                channel_results = []
                for i,op in enumerate(self.tmin_results[channel]):
                    if op.operator_info.isGenIrrep():
                        irrep = op.operator_info.getGenIrrep().getLGIrrep()
                    else:
                        irrep = op.operator_info.getBasicLapH().getLGIrrep()
                    for model in self.tmin_results[channel][op]["fits"]:
                        for tmin in self.tmin_results[channel][op]["fits"][model]:
                            if self.tmin_results[channel][op]["fits"][model][tmin] and tmin!="info":
                                # energy_index = self.tmin_results[channel][op]["fits"][model]["info"].energy_index
                                simple_result = {
                                    "isospin": channel.isospin,
                                    "strangeness": channel.strangeness,
                                    "irrep": irrep,
                                    "momentum": op.psq,
                                    "rotate level": op.level,
                                    "model": model,
                                    "tmin": tmin,
                                    "tmax": self.tmin_results[channel][op]["fits"][model]["info"].tmax,
                                    "elab value": self.tmin_results[channel][op]["fits"][model][tmin]["elab"].getFullEstimate(),
                                    "elab error": self.tmin_results[channel][op]["fits"][model][tmin]["elab"].getSymmetricError(),
                                    "chisqrdof": self.tmin_results[channel][op]["fits"][model][tmin]["chisqrdof"],
                                    "qual": self.tmin_results[channel][op]["fits"][model][tmin]["qual"],
                                    "dof": self.tmin_results[channel][op]["fits"][model][tmin]["dof"],
                                }
                                if str(channel) in self.other_params['non_interacting_levels']:
                                    # print(channel)
                                    simple_result["dElab value"] = self.tmin_results[channel][op]["fits"][model][tmin]["dElab"].getFullEstimate()
                                    simple_result["dElab error"] = self.tmin_results[channel][op]["fits"][model][tmin]["dElab"].getSymmetricError()
                                    simple_result["non-interacting level"] = self.other_params['non_interacting_levels'][str(channel)][i]
                                channel_results.append(simple_result)
                out_results += channel_results
            df = pd.DataFrame.from_dict(out_results)
            df.to_csv(self.spectrum_tmin_estimates, index=False, header=True)
            logging.info(f"Wrote varying tmin fit estimates to file {self.spectrum_tmin_estimates}.")

    #sort single hadron channel based on operator list given
    def sh_channel_sort(self, item): 
        for particle in self.other_params['single_hadrons']:
            for i,op in enumerate(self.other_params['single_hadrons'][particle]):
                thisop = operator.Operator(op)
                if thisop.channel == item:
                    break
            if thisop.channel == item:
                break
        return f"{particle}{i}"
    

    def plot( self ):
        if self.other_params['plot']:
            logging.info(f"Saving plots to directory {self.proj_files_handler.plot_dir()}...")
        else:
            logging.info(f"No plots requested.")
            return
        
        #sort channel order
        self.single_hadron_channels.sort(key=self.sh_channel_sort)
        self.interacting_channels.sort(key=sigmond_util.channel_sort)
        
        #set up plotting handler
        plh = ph.PlottingHandler()
        plh.create_fig(15,8) #self.other_params['figwidth'], self.other_params['figheight'])

        # self.project_handler.nodes = 0
        start_time = time.time()
        if self.project_handler.nodes:
            processes = []
            ip = 0

        if self.other_params["do_interacting_fits"]:
            if self.project_handler.nodes:
                processes.append(Process(target=self.summary_spectrum_plot,args=(plh,)))
                processes[-1].start()
                ip += 1
            else:
                self.summary_spectrum_plot(plh)
        
        all_sim_fit_plots = {}
        # all_op_overlap_plots = {}

        #fit plots
        plh.set_figsize(self.other_params['figwidth'], self.other_params['figheight'])
        all_channels = [('sh',channel) for channel in self.single_hadron_channels]
        all_channels += [('int',channel) for channel in self.interacting_channels]
        for ctype, channel in all_channels:
            results = {}
            if ctype=='sh':
                results.update(self.single_hadron_results[channel])
            else:
                results.update(self.results[channel])

            if results:
                all_sim_fit_plots[channel] = {}
                logging.info(f"\tGenerating plots for channel {str(channel)}...")
                # if self.other_params['create_summary']:
                    # if not entered_interacting_section and channel in self.interacting_channels:
                    #     plh.append_section(str("Interacting Levels"))
                    #     entered_interacting_section = True
                    # plh.append_subsection(str(channel))

                for op in results:
                    #plott corr and fit 
                    op_name = str(op).replace(" ","_")
                    this_op = op
                    if results[op]["success"]:
                        if results[op]["info"].ratio:
                            this_op = op.ratio_op
                        corr = sigmond.CorrelatorInfo(this_op.operator_info,this_op.operator_info)
                        estimates = sigmond.getCorrelatorEstimates(self.mcobs_handler,corr,self.project_handler.hermitian,
                                                                   self.project_handler.subtract_vev,sigmond.ComplexArg.RealPart, 
                                                                   self.project_handler.project_info.sampling_info.getSamplingMode())
                        df = sigmond_util.estimates_to_df(estimates)

                        plh.clf()
                        if self.project_handler.nodes:
                            pickle_file = ""
                            pdf_file = ""
                            if self.other_params['create_pickles']:
                                pickle_file = self.proj_files_handler.corr_plot_file( op_name, "pickle")
                            if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                                pdf_file = self.proj_files_handler.corr_plot_file( op_name, "pdf")

                            if len(processes)<self.project_handler.nodes:
                                processes.append(Process(target=plh.sigmond_corrfit_plot_and_save,
                                                         args=(df, results[op], self.ensemble_info.getLatticeTimeExtent(), 0, None,pickle_file, pdf_file,)))
                                processes[-1].start()
                            else:
                                processes[ip].join()
                                processes[ip] = Process(target=plh.sigmond_corrfit_plot_and_save,
                                                        args=(df, results[op], self.ensemble_info.getLatticeTimeExtent(), 0, None,pickle_file, pdf_file,))
                                processes[ip].start()
                            ip = sigmond_util.update_process_index(ip,self.project_handler.nodes)
                        else:
                            plh.sigmond_corrfit_plot(df, results[op], self.ensemble_info.getLatticeTimeExtent(), 0) #, this_op) #0 for regular corr plot

                            if self.other_params['create_pickles']:
                                plh.save_pickle(self.proj_files_handler.corr_plot_file( op_name, "pickle"))
                            if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                                plh.save_pdf(self.proj_files_handler.corr_plot_file( op_name, "pdf"))

                        estimates = sigmond.getEffectiveEnergy(self.mcobs_handler,corr,self.project_handler.hermitian,
                                                               self.project_handler.subtract_vev,sigmond.ComplexArg.RealPart, 
                                                               self.project_handler.project_info.sampling_info.getSamplingMode(),
                                                               self.project_handler.time_separation,
                                                               self.project_handler.effective_energy_type,
                                                               self.project_handler.vev_const)
                        df = sigmond_util.estimates_to_df(estimates)

                        plh.clf()
                        if self.project_handler.nodes:
                            pickle_file = ""
                            pdf_file = ""
                            if self.other_params['create_pickles']:
                                pickle_file = self.proj_files_handler.effen_plot_file( op_name, "pickle")
                            if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                                pdf_file = self.proj_files_handler.effen_plot_file( op_name, "pdf")

                            if len(processes)<self.project_handler.nodes:
                                processes.append(Process(target=plh.sigmond_corrfit_plot_and_save,
                                                         args=(df, results[op], self.ensemble_info.getLatticeTimeExtent(), 1, this_op,pickle_file, pdf_file,)))
                                processes[-1].start()
                            else:
                                processes[ip].join()
                                processes[ip] = Process(target=plh.sigmond_corrfit_plot_and_save,
                                                        args=(df, results[op], self.ensemble_info.getLatticeTimeExtent(), 1, this_op,pickle_file, pdf_file,))
                                processes[ip].start()
                            ip = sigmond_util.update_process_index(ip,self.project_handler.nodes)
                        else:
                            plh.sigmond_corrfit_plot(df, results[op], self.ensemble_info.getLatticeTimeExtent(), 1) #, this_op) #0 for regular corr plot

                            if self.other_params['create_pickles']:
                                plh.save_pickle(self.proj_files_handler.effen_plot_file( op_name, "pickle"))
                            if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                                plh.save_pdf(self.proj_files_handler.effen_plot_file( op_name, "pdf"))

                        # if self.other_params['create_summary']:
                        #     plh.add_correlator_subsection(str(op),self.proj_files_handler.corr_plot_file( op_name, "pdf"),
                        #                                     self.proj_files_handler.effen_plot_file( op_name, "pdf"))
                        
                        sim_plot_files = []
                        if results[op]["info"].sim_fit:
                            ni_levels = self.other_params['non_interacting_levels'][str(channel)][op.level]
                            for i,sh in enumerate(OrderedSet(ni_levels)):
                                plh.clf()
                                shop = self.get_sh_operator(sh)
                                corr = sigmond.CorrelatorInfo(shop.operator_info,shop.operator_info)
                                estimates = sigmond.getEffectiveEnergy(self.mcobs_handler,corr,self.project_handler.hermitian,
                                                                       self.project_handler.subtract_vev,sigmond.ComplexArg.RealPart, 
                                                                       self.project_handler.project_info.sampling_info.getSamplingMode(),
                                                                       self.project_handler.time_separation,
                                                                       self.project_handler.effective_energy_type,
                                                                       self.project_handler.vev_const)
                                shtmin = self.single_hadron_results[shop.channel][shop]["info"].tmin
                                shtmax = self.single_hadron_results[shop.channel][shop]["info"].tmax
                                df = sigmond_util.estimates_to_df(estimates)
                                plh.sigmond_corrfit_plot(df, self.results[channel][op], self.ensemble_info.getLatticeTimeExtent(), 1, shop, i+1, new_trange=(shtmin,shtmax))
                                if self.other_params['create_pickles']:
                                    plh.save_pickle(self.proj_files_handler.effen_plot_file( f"{op_name}-{sh}", "pickle"))
                                if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                                    plh.save_pdf(self.proj_files_handler.effen_plot_file( f"{op_name}-{sh}", "pdf"))
                                sim_plot_files.append(self.proj_files_handler.effen_plot_file( f"{op_name}-{sh}", "pdf"))

                    # else:
                    #     plh.append_subsubsection(str(op))
                        
                    if channel in self.tmin_results:
                        if op in self.tmin_results[channel]:
                            for energy_type in ["elab","dElab"]:
                                sim_fits = self.tmin_fit_plot(plh, energy_type, results, channel, op, op_name)
                            # if self.other_params['create_summary'] and os.path.exists(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf", "tmin")):
                            #     plh.include_additional_plots(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf","tmin"),
                            #                                  self.proj_files_handler.corr_fit_series_plot_file(op_name,"dElab","pdf","tmin"))
                            if sim_fits:
                                for sh, sh_tmin in sim_fits.items():
                                    sh_op = self.get_sh_operator(sh)
                                    ind_fit = self.single_hadron_results[sh_op.channel][sh_op]
                                    ind_fit_estimate = ind_fit["estimates"][ind_fit["info"].energy_index]
                                    sim_plot_files.append(self.sim_tmin_plot(sh,sh_tmin, op_name, plh, ind_fit_estimate))
                    if channel in self.tmax_results:
                        if op in self.tmax_results[channel]:
                            for energy_type in ["elab","dElab"]:
                                sim_fits = self.tmin_fit_plot(plh, energy_type, results, channel, op, op_name, False)
                            # if self.other_params['create_summary'] and os.path.exists(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf","tmax")):
                            #     plh.include_additional_plots(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf","tmax"),
                            #                                  self.proj_files_handler.corr_fit_series_plot_file(op_name,"dElab","pdf","tmax"))
                            if sim_fits:
                                for sh, sh_tmin in sim_fits.items():
                                    sh_op = self.get_sh_operator(sh)
                                    ind_fit = self.single_hadron_results[sh_op.channel][sh_op]
                                    ind_fit_estimate = ind_fit["estimates"][ind_fit["info"].energy_index]
                                    sim_plot_files.append(self.sim_tmin_plot(sh,sh_tmin, op_name, plh, ind_fit_estimate, False))

                    
                    all_sim_fit_plots[channel][op] = sim_plot_files
                    # if sim_plot_files and self.other_params['create_summary']:
                    #     plh.add_plot_series(sim_plot_files)

                #plot operator overlaps for interacting channels
                if self.other_params["compute_overlaps"] and channel in self.interacting_channels:
                    if channel in self.zmags:
                        if self.project_handler.nodes:
                            if len(processes)<self.project_handler.nodes:
                                processes.append(Process(target=self.generate_operator_overlaps_plots, args=(channel, plh,)))
                                processes[-1].start()
                            else:
                                processes[ip].join()
                                processes[ip] = Process(target=self.generate_operator_overlaps_plots, args=(channel, plh,))
                                processes[ip].start()
                            ip = sigmond_util.update_process_index(ip,self.project_handler.nodes)
                        else:
                            self.generate_operator_overlaps_plots(channel, plh)

                        # files = []
                                # files.append(self.proj_files_handler.operator_overlaps_plot( op_name, "pdf"))

                        # all_op_overlap_plots[channel] = files
                        # if self.other_params['create_summary']:
                        #     plh.add_operator_overlaps(files)

        if self.project_handler.nodes:
            for process in processes:
                process.join()

        print("Total plot time:", time.time()-start_time)

        #set up summary document, add summary plot and then tables
        if self.other_params['create_summary']:
            plh.create_summary_doc("Fitted Correlators")
            plh.append_section("Summary")
            if self.interacting_channels:
                plh.add_single_plot(self.proj_files_handler.summary_plot_file("pdf"))

            #add single hadron table
            data = []
            for channel in self.single_hadron_channels:
                for op in self.single_hadron_results[channel]:
                    if self.single_hadron_results[channel][op]["success"]:
                        this_fit = self.single_hadron_results[channel][op]
                        single_hadron, _ = self.get_single_hadron(str(op))
                        line = [single_hadron, channel.psq, channel.irrep]
                        # line+=[utils.nice_value(this_fit["ecm_ref"].getFullEstimate(),this_fit["ecm_ref"].getSymmetricError())]
                        line+=[utils.nice_value(this_fit["elab"].getFullEstimate(),this_fit["elab"].getSymmetricError())]
                        line+=[this_fit["info"].model.short_name]
                        line+=[f"[{this_fit['info'].tmin},{this_fit['info'].tmax}]"]
                        line+=[format(this_fit["qual"],".2f")]
                        data.append(line)
            headers = ["Name",r"$d^2$",r"$\Lambda$", r"$a_tE_{\textup{lab}}$", 
                        "Fit Model", "$t$-range", "$p$-val"] #,rf"$E_{{\textup{{cm}}}}/E_{{latex_rest_mass}}$"
            plh.summary_table(self.other_params['reference_particle'],headers,data,"Single Hadrons")

            #add spectrum table
            if self.interacting_channels:
                data = []
                old_channel = f"iso{self.interacting_channels[0].isospin} S={self.interacting_channels[0].strangeness} $d^2$={self.interacting_channels[0].psq}"
                #mom irrep level ecm_ref elab dElab model (tmin,tmax) qual NI
                if self.other_params['reference_particle']:
                    headers = [r"$d^2$",r"$\Lambda$","Level",rf"$E_{{\textup{{cm}}}}/E_{{latex_rest_mass}}$", r"$a_tE_{\textup{lab}}$", 
                                        r"$a_t\delta E_{\textup{lab}}$", "Fit Model", "$t$-range", "$p$-val", "NI"]
                else:
                    headers = [r"$d^2$",r"$\Lambda$","Level",rf"$E_{{\textup{{cm}}}}$", r"$a_tE_{\textup{lab}}$", 
                                        r"$a_t\delta E_{\textup{lab}}$", "Fit Model", "$t$-range", "$p$-val", "NI"]
                for channel in self.interacting_channels: #group by isospin and strangeness
                    complete = True
                    channel_data = []

                    new_channel = f"iso{channel.isospin} S={channel.strangeness} $d^2$={channel.psq}" #separate tables by isospin and strangeness
                    if new_channel!=old_channel:
                        plh.summary_table(self.other_params['reference_particle'],headers,data,old_channel)
                        data = []
                        old_channel = new_channel

                    for op in self.results[channel]:
                        if self.results[channel][op]["success"]:
                            this_fit = self.results[channel][op]
                            line = [channel.psq, channel.irrep, op.level]
                            if self.other_params['reference_particle']:
                                line+=[utils.nice_value(this_fit["ecm_ref"].getFullEstimate(),this_fit["ecm_ref"].getSymmetricError())]
                            else:
                                line+=[utils.nice_value(this_fit["ecm"].getFullEstimate(),this_fit["ecm"].getSymmetricError())]
                            line+=[utils.nice_value(this_fit["elab"].getFullEstimate(),this_fit["elab"].getSymmetricError())]
                            if "dElab" in this_fit:
                                line+=[utils.nice_value(this_fit["dElab"].getFullEstimate(),this_fit["dElab"].getSymmetricError())]
                            else:
                                line+=[""]
                            line+=[this_fit["info"].model.short_name]
                            if this_fit["info"].ratio:
                                line[-1]+="-ratio"
                            line+=[f"[{this_fit['info'].tmin},{this_fit['info'].tmax}]"]
                            ni = self.other_params['non_interacting_levels'][str(channel)][op.level]
                            line+=[format(this_fit["qual"],".2f"),"".join(ni)]
                            channel_data.append(line)
                        else:
                            complete = False

                    if complete:
                        channel_data.sort(key=table_sort_set(3)) #sort lines by increating energy
                        for i,line in enumerate(channel_data):
                            line[2] = rf"${line[2]} \to {i}$"#add reorder info
                    data+=channel_data

                plh.summary_table(self.other_params['reference_particle'],headers,data,old_channel)

            plh.append_section(str("Single Hadrons"))
            
            entered_interacting_section = False
            for ctype, channel in all_channels:
                results = {}
                if ctype=='sh':
                    results.update(self.single_hadron_results[channel])
                else:
                    results.update(self.results[channel])
                if results:
                    if not entered_interacting_section and ctype=='int':
                        plh.append_section(str("Interacting Levels"))
                        entered_interacting_section = True
                    plh.append_subsection(str(channel))
                    for op in results:
                        #plott corr and fit 
                        op_name = str(op).replace(" ","_")
                        this_op = op
                        if results[op]["success"]:
                            plh.add_correlator_subsection(str(op),self.proj_files_handler.corr_plot_file( op_name, "pdf"),
                                                            self.proj_files_handler.effen_plot_file( op_name, "pdf"))
                        else:
                            plh.append_subsubsection(str(op))

                        if channel in self.tmin_results:
                            if op in self.tmin_results[channel]:
                                if os.path.exists(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf", "tmin")):
                                    plh.include_additional_plots(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf","tmin"),
                                                                self.proj_files_handler.corr_fit_series_plot_file(op_name,"dElab","pdf","tmin"))
                        if channel in self.tmax_results:
                            if op in self.tmax_results[channel]:
                                if os.path.exists(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf","tmax")):
                                    plh.include_additional_plots(self.proj_files_handler.corr_fit_series_plot_file( op_name, "elab", "pdf","tmax"),
                                                                self.proj_files_handler.corr_fit_series_plot_file(op_name,"dElab","pdf","tmax"))

                        if op in all_sim_fit_plots[channel]:
                            if all_sim_fit_plots[channel][op]:
                                plh.add_plot_series(all_sim_fit_plots[channel][op])
                            
                    if self.other_params["compute_overlaps"] and channel in self.interacting_channels:
                        if channel in self.zmags:
                            files = []
                            for i,op in enumerate(self.zmags[channel]["ops"]):
                                op_name = str(op).replace(" ","_")
                                files.append(self.proj_files_handler.operator_overlaps_plot( op_name, "pdf"))
                            # if all_op_overlap_plots[channel]:
                            plh.add_operator_overlaps(files)

            #finalize summary plot
            plh.compile_pdf(self.proj_files_handler.summary_file()) 
            logging.info(f"Summary file saved to {self.proj_files_handler.summary_file()}.pdf")
            
    #summary spectrum plot
    def summary_spectrum_plot(self,plh):
        all_levels = []; all_errs = []; all_indexes = []; xticks = []
        if self.other_params['reference_particle']:
            if f"{self.other_params['reference_particle']}(0)" in self.single_hadron_info:
                energy_key = "ecm_ref"
            else:
                energy_key = "ecm"
        else:
            energy_key = "ecm"
        for i,channel in enumerate(self.interacting_channels):
            levels = []; errs = []
            for op in self.results[channel]:
                if self.results[channel][op]["success"]:
                    levels.append(self.results[channel][op][energy_key].getFullEstimate())
                    errs.append(self.results[channel][op][energy_key].getSymmetricError())
            index = [i]*len(levels)
            all_levels+=levels; all_errs+=errs; all_indexes+=index
            xticks+=[(channel.irrep,channel.psq)]

        thresholds = []
        for line in self.other_params["thresholds"]:
            value = 0.0
            for particle in line:
                value+=self.single_hadron_info[particle+"(0)"][energy_key]
            thresholds.append((line, value))

        if all_indexes:
            plh.summary_plot(all_indexes,all_levels,all_errs,xticks,self.other_params['reference_particle'],thresholds)
            if self.other_params['create_pickles']:
                plh.save_pickle(self.proj_files_handler.summary_plot_file("pickle"))
            if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                plh.save_pdf(self.proj_files_handler.summary_plot_file("pdf"))

    #generates the tmin or tmax plot for any given operator op
    def tmin_fit_plot(self, plh, energy_type, results, channel, op, op_name, tmin_plot=True):
        plh.clf()
        sim_fits = {} #sh, model, tmin, estimate
        empty_plot = True
        if tmin_plot:
            fit_series_results = self.tmin_results
        else:
            fit_series_results = self.tmax_results

        mom = channel.psq
        if op.operator_info.isBasicLapH():
            hadrons = op.operator_info.getBasicLapH().getNumberOfHadrons()
        else:
            opname = op.operator_info.getGenIrrep().getIDName()
            hadrons = count_hadrons(opname) 
        species = None
        if mom==0 and hadrons == 1:
            species, _ = self.get_single_hadron(str(op))

        if energy_type in results[op]:
            plh.add_chosen_fit(results[op][energy_type].getFullEstimate(), results[op][energy_type].getSymmetricError())
            for i,model in enumerate(fit_series_results[channel][op]["fits"].keys()):
                tmins = []; energies = []; energy_errs = []; pvals = []
                if '-sim' in model:
                    for sh in OrderedSet(self.other_params['non_interacting_levels'][str(channel)][op.level]):
                        if sh not in sim_fits:
                            sim_fits[sh] = {}
                        sim_fits[sh][model] = {}
                        sim_fits[sh][model]["fit_vals"] = {}
                        sim_fits[sh][model]["pval"] = {}
                        sim_fits[sh][model]["color"] = i
                for tmin,val in fit_series_results[channel][op]["fits"][model].items():
                    if tmin!="info" and val:
                        tmins.append(tmin); energies.append(val[energy_type].getFullEstimate())
                        energy_errs.append(val[energy_type].getSymmetricError())
                        pvals.append(val["qual"])
                        if '-sim' in model:
                            if model=="2-exp-sim":
                                init_param = fit_series_results[channel][op]["fits"][model]["info"].num_params #get energy index of sh model
                                step_param = 3 #get param num of sh model
                            for sh in OrderedSet(self.other_params['non_interacting_levels'][str(channel)][op.level]):
                                sim_fits[sh][model]["fit_vals"][tmin] = val["estimates"][init_param] 
                                sim_fits[sh][model]["pval"][tmin] = val["qual"]
                                init_param+=step_param
                if tmins:
                    empty_plot = False
                    sort_data = list(zip(tmins, energies, energy_errs, pvals))
                    sort_data.sort(key=lambda x: x[-1])
                    for split, data in enumerate(sort_data):
                        if data[-1]>=0.1:
                            break
                    if sort_data[:split]:
                        label = None
                        if not sort_data[split:]:
                            label=model
                        tmins, energies, energy_errs, pvals = list(zip(*sort_data[:split])) #poor pval
                        plh.add_fit_series(tmins, energies, energy_errs, i, False, label)
                    if sort_data[split:]:
                        tmins, energies, energy_errs, pvals = list(zip(*sort_data[split:])) #good pval
                        plh.add_fit_series(tmins, energies, energy_errs, i, True, model)

            if tmin_plot:
                series_type = "min"
            else: 
                series_type = "max"
            if not empty_plot:
                label = None
                if hadrons!=1:
                    irrep = psettings.latex_format[channel.irrep]
                    label = f"{irrep}({mom}) level {op.level} "
                    for sh in self.other_params['non_interacting_levels'][str(channel)][op.level]:
                        label+=sh.replace(sh.split('(')[0], psettings.latex_format[sh.split('(')[0]])

                plh.finalize_fit_series_plot(series_type,label,ratio=(energy_type=="dElab"),species=species)
                if self.other_params['create_pickles']:
                    plh.save_pickle(self.proj_files_handler.corr_fit_series_plot_file( op_name, energy_type, "pickle",'t'+series_type))
                if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                    plh.save_pdf(self.proj_files_handler.corr_fit_series_plot_file( op_name, energy_type, "pdf",'t'+series_type))
            else:
                if os.path.exists(self.proj_files_handler.corr_fit_series_plot_file( op_name, energy_type, "pickle",'t'+series_type)):
                    os.remove(self.proj_files_handler.corr_fit_series_plot_file( op_name, energy_type, "pickle",'t'+series_type))
                if os.path.exists(self.proj_files_handler.corr_fit_series_plot_file( op_name, energy_type, "pdf",'t'+series_type)):
                    os.remove(self.proj_files_handler.corr_fit_series_plot_file( op_name, energy_type, "pdf",'t'+series_type))
        return sim_fits

    #check that model, tmin, and tmax are specified in all default fit configurations
    def check_fit_inputs(self, fit_input, task_configs, fit_input_name):
        
        for item in ['model','tmin','tmax']:
            if item not in fit_input:
                logging.error(f"Parameter '{item}' missing from {fit_input_name} input.")

        for param, setting in self.default_fit_params.items():
            if param not in fit_input:
                sfit_input = setting
                task_configs[fit_input_name][param] = setting

    #sets up tmin or tmax plot for fits that were done in parallel to the central correlator
    def sim_tmin_plot(self, sh,sh_tmin, op_name, plh, ind_fit_estimate, tmin_plot = True):
        plh.clf()
        plh.add_chosen_fit(ind_fit_estimate.getFullEstimate(), ind_fit_estimate.getSymmetricError(), "Ind. fit")
        for model in sh_tmin:
            tmins = list(sh_tmin[model]["fit_vals"].keys())
            energy_est = list(sh_tmin[model]["fit_vals"].values())
            pvals = list(sh_tmin[model]["pval"].values())
            energies = [en.getFullEstimate() for en in energy_est]
            energy_errs = [en.getSymmetricError() for en in energy_est]
            
            sort_data = list(zip(tmins, energies, energy_errs, pvals))
            sort_data.sort(key=lambda x: x[-1])
            if sort_data:
                for split, data in enumerate(sort_data):
                    if data[-1]>=0.1:
                        break
                if sort_data[:split]:
                    label = None
                    if not sort_data[split:]:
                        label=model
                    tmins, energies, energy_errs, pvals = list(zip(*sort_data[:split])) #poor pval
                    plh.add_fit_series(tmins, energies, energy_errs, sh_tmin[model]["color"], False, label)
                if sort_data[split:]:
                    tmins, energies, energy_errs, pvals = list(zip(*sort_data[split:])) #good pval
                    plh.add_fit_series(tmins, energies, energy_errs, sh_tmin[model]["color"], True, model)
            
        if tmin_plot:
            series_type = "min"
        else: 
            series_type = "max"
        plh.finalize_fit_series_plot(series_type,title=f"{sh}")
        if self.other_params['create_pickles']:
            plh.save_pickle(self.proj_files_handler.corr_fit_series_plot_file( f"{op_name}-{sh}", "dElab", "pickle",'t'+series_type))
        if self.other_params['create_pdfs'] or self.other_params['create_summary']:
            plh.save_pdf(self.proj_files_handler.corr_fit_series_plot_file( f"{op_name}-{sh}", "dElab", "pdf",'t'+series_type))
            # logging.info("Generated sim tmin plot: "+self.corr_fit_series_plot_file( f"{op_name}-{sh}", "dElab", "pdf"))
        return(self.proj_files_handler.corr_fit_series_plot_file( f"{op_name}-{sh}", "dElab", "pdf",'t'+series_type))
    
    #for a given channel, generate all the operator overlap plots
    def generate_operator_overlaps_plots(self, channel, plh):
        for i,op in enumerate(self.zmags[channel]["ops"]):
            op_name = str(op).replace(" ","_")
            if op.isBasicLapH():
                oppiece = op.getBasicLapH().getIDName()
            else:
                oppiece = op.getGenIrrep().getIDName()
            estimates = []
            errors = []
            for j in range(self.zmags[channel]["nlevels"]):
                zmag = self.zmags[channel]["zmags"].get(i,j)
                estimates.append(zmag.getFullEstimate())
                errors.append(zmag.getSymmetricError())
            plh.clf()
            
            plh.plot_operator_overlaps(estimates,errors,oppiece)
            if self.other_params['create_pdfs'] or self.other_params['create_summary']:
                plh.save_pdf(self.proj_files_handler.operator_overlaps_plot( op_name, "pdf"))
            if self.other_params['create_pickles']:
                for i in range(10):
                    try:
                        plh.save_pickle(self.proj_files_handler.operator_overlaps_plot( op_name, "pickle"))
                        break
                    except RuntimeError as err:
                        logging.warning(f"Runtime error when saving pickle of overlaps: {err}.")

    #for a given operator, complete the fit and tmin variation fits and store relevant info into memory
    def do_fits( self, results, channel, intop, this_fit_input, wmode, param_file, hadrons, tmin_results, tmax_results):
        #chosen fit
        task_input = sigmond_input.SigmondInput(
            os.path.basename(self.project_handler.project_info.project_dir),
            self.project_handler.project_info.bins_info,
            self.project_handler.project_info.sampling_info,
            self.project_handler.project_info.ensembles_file,
            self.data_files,
            "temp1.xml",
            os.path.join(self.proj_files_handler.log_dir(),"sigmond_spectrum_log.xml"), #actually creating this
            self.other_params['precompute'],
            None,
        )
        results[channel][intop] = {}
        fitenergy_obs_info = None
        fitamp_obs_info = None
        model=this_fit_input['model']
        scat_info = []
        sh_priors = {}
        if this_fit_input["sim_fit"]:
            model+="-sim"
            if not self.set_up_sim_fit(this_fit_input, model, scat_info, sh_priors, channel, intop):
                results[channel][intop]["success"] = False
                return
            scat_info_initial = scat_info[0]
        
        if model!='multi-exp':
            this_fit_input['model'] = fit_info.FitModel(this_fit_input['model'])
        try:
            if self.other_params['minimizer_info']['minimizer']=='lmder':
                if model!='multi-exp':
                    this_fit_info, these_fit_results, chisqr, qual, dof = sigmond_util.sigmond_fit(task_input, intop, self.other_params['minimizer_info'], this_fit_input, self.mcobs_handler, 
                                                    self.project_handler.project_info.sampling_info.getSamplingMode(), self.project_handler.subtract_vev, self.fit_log_file(intop), False, 
                                                    sh_priors, scat_info)
                else:
                    multi_exp_input = {}
                    multi_exp_input.update(this_fit_input)
                    multi_exp_input['tmin'] = 2
                    this_fit_info, these_fit_results, chisqr, qual, dof = sigmond_util.sigmond_multi_exp_fit(task_input, intop, self.other_params['minimizer_info'], multi_exp_input, self.mcobs_handler, 
                                        self.project_handler.project_info.sampling_info.getSamplingMode(), self.project_handler.subtract_vev, self.fit_log_file(intop), False)
            else:
                nsamplings = self.project_handler.project_info.sampling_info.getNumberOfReSamplings(self.project_handler.project_info.bins_info)
                this_fit_info, these_fit_results, chisqr, qual, dof = sigmond_util.scipy_fit(intop, self.other_params['minimizer_info'], this_fit_input, self.mcobs_handler, 
                                                self.project_handler.subtract_vev, self.project_handler.hermitian, self.ensemble_info.getLatticeTimeExtent(), 
                                                self.project_handler.nodes, nsamplings, False, sh_priors, scat_info)
            results[channel][intop]["success"] = True
            results[channel][intop]["info"] = this_fit_info
            results[channel][intop]["estimates"] = these_fit_results
            results[channel][intop]["chisqrdof"] = float(chisqr)
            results[channel][intop]["qual"] = float(qual)
            results[channel][intop]["dof"] = int(dof)
            fitenergy_obs_info = this_fit_info.energy_observable 
            fitamp_obs_info = this_fit_info.amplitude_observable

            #set up MCObsInfo for important quantities
            delab_obs_info = this_fit_info.fit_param_obs(this_fit_info.num_params+Obs.dElab.value) 
            elab_obs_info = this_fit_info.fit_param_obs(this_fit_info.num_params+Obs.elab.value)
            ecm_obs_info = this_fit_info.fit_param_obs(this_fit_info.num_params+Obs.ecm.value)
            amp_obs_info = this_fit_info.fit_param_obs(this_fit_info.num_params+Obs.amp.value) 

            if "non_interacting_level" in this_fit_input:
                this_ni_level = this_fit_input["non_interacting_level"]
                if this_fit_info.sim_fit:
                    if scat_info[0]!=scat_info_initial:
                        self.other_params['non_interacting_levels'][str(channel)][intop.level].reverse()
                    this_ni_level = get_sim_ni_level(this_fit_input["non_interacting_level"],this_fit_info.obs_name,scat_info)

            if this_fit_info.ratio: 
                #compute ecm and elab
                sigmond.doLinearSuperpositionBySamplings(self.mcobs_handler,[fitenergy_obs_info],[1.0],delab_obs_info)
                Nx = self.ensemble_info.getLatticeXExtent()
                factor = 6.2831853071795864770
                mom_factor = factor*factor/Nx/Nx
                ni_levels = [(sh,mom*mom_factor) for sh,mom in this_ni_level]
                sigmond.doReconstructEnergyBySamplings(self.mcobs_handler,delab_obs_info,ni_levels,elab_obs_info)
                results[channel][intop]["elab"] = self.mcobs_handler.getEstimate(elab_obs_info)
                results[channel][intop]["dElab"] = these_fit_results[this_fit_info.energy_index]
                ni_levels = [self.single_hadron_info[sh]["amp_obs"] for sh in self.other_params["non_interacting_levels"][str(channel)][intop.level]]
                sigmond.doReconstructAmplitudeBySamplings(self.mcobs_handler, fitamp_obs_info,ni_levels,amp_obs_info)
            else:
                #compute dElab if possible
                results[channel][intop]["elab"] = these_fit_results[this_fit_info.energy_index]
                sigmond.doLinearSuperpositionBySamplings(self.mcobs_handler,[fitenergy_obs_info],[1.0],elab_obs_info)
                sigmond.doLinearSuperpositionBySamplings(self.mcobs_handler,[fitamp_obs_info],[1.0],amp_obs_info)
                if "non_interacting_level" in this_fit_input:
                    Nx = self.ensemble_info.getLatticeXExtent() #assuming Nx=Ny=Nz
                    factor = 6.2831853071795864770 
                    ni_levels = [(sh,mom*factor*factor/Nx/Nx) for sh,mom in this_ni_level]
                    #compute delab
                    sigmond.doEnergyDifferenceBySamplings(self.mcobs_handler,elab_obs_info,ni_levels,delab_obs_info)
                    results[channel][intop]["dElab"] = self.mcobs_handler.getEstimate(delab_obs_info)

                    #used correlated sim fit to construct the shift, but then use rest mass fit
                        #and dispersion relation to shift back to elab
                    if this_fit_info.sim_fit:
                        ni_levels = [(sh,mom*factor*factor/Nx/Nx) for sh,mom in this_fit_input["non_interacting_level"]]
                        sigmond.doReconstructEnergyBySamplings(self.mcobs_handler,delab_obs_info,ni_levels,elab_obs_info)
                        results[channel][intop]["elab"] = self.mcobs_handler.getEstimate(elab_obs_info)
            
            if intop.channel.psq==0:
                results[channel][intop]["ecm"] = results[channel][intop]["elab"]
            else:
                Nx = self.ensemble_info.getLatticeXExtent() #assuming Nx=Ny=Nz
                factor = 6.2831853071795864770
                sigmond.doBoostBySamplings(self.mcobs_handler,elab_obs_info,-intop.channel.psq*factor*factor/Nx/Nx,ecm_obs_info)
                results[channel][intop]["ecm"] = self.mcobs_handler.getEstimate(ecm_obs_info)

        except ValueError as err:
            logging.warning(f"Fit to {intop} failed: {err}.")
            results[channel][intop]["success"] = False
        except RuntimeError as err:
            logging.warning(f"Fit to {intop} failed: {err}.")
            results[channel][intop]["success"] = False

        #save samplings to param file
        if results[channel][intop]["success"]:
            obs_name = results[channel][intop]["info"].obs_name
            obs_infos = set()
            for i in range(results[channel][intop]["info"].num_params):
                obs_id = results[channel][intop]["info"].obs_id(i)
                obs_infos.add(sigmond.MCObsInfo(obs_name,obs_id))

            dummy = sigmond.XMLHandler("test")
            self.mcobs_handler.writeSamplingValuesToFile(obs_infos,param_file, dummy, wmode,"H")

            #delete samplings unless single hadron
            if hadrons!=1:
                for param in obs_infos:
                    self.mcobs_handler.eraseSamplings(param)

        #do tmin_fits
        tmin_results[channel][intop] = {}
        tmin_results[channel][intop]["fits"] = {}
        if 'tmin_plots' in this_fit_input:
            for plot in this_fit_input['tmin_plots']:
                self.fit_model_series( plot, this_fit_input, channel, intop, tmin_results)
        tmax_results[channel][intop] = {}
        tmax_results[channel][intop]["fits"] = {}
        if 'tmax_plots' in this_fit_input:
            for plot in this_fit_input['tmax_plots']:
                self.fit_model_series( plot, this_fit_input, channel, intop, tmax_results)
        return fitenergy_obs_info, fitamp_obs_info
    
    def fit_model_series(self, plot, this_fit_input, channel, intop, results ):
        model = plot['model']
        sh_priors = {}
        scat_info = []
        if "ratio" in plot:
            if "non_interacting_level" not in this_fit_input:
                return
            if plot["ratio"]:
                model+="-ratio"
        if "sim_fit" in plot:
            if plot["sim_fit"]:
                model+="-sim"
                if not self.set_up_sim_fit(plot, model, scat_info, sh_priors, channel, intop):
                    return
                scat_info_initial = scat_info[0]

        results[channel][intop]["fits"][model] = {}
        results[channel][intop]["fits"][model]["info"] = None

        if 'tmin_min' in plot and 'tmin_max' in plot:
            tstart = plot['tmin_min']
            tstop = plot['tmin_max']
        elif 'tmax_min' in plot and 'tmax_max' in plot:
            tstart = plot['tmax_min']
            tstop = plot['tmax_max']
        else:
            logging.error("Parameters for tmin or tmax plot are incomplete.")

        for i in range(tstart,tstop+1):

            task_input = sigmond_input.SigmondInput(
                os.path.basename(self.project_handler.project_info.project_dir),
                self.project_handler.project_info.bins_info,
                self.project_handler.project_info.sampling_info,
                self.project_handler.project_info.ensembles_file,
                self.data_files,
                "temp1.xml",
                os.path.join(self.proj_files_handler.log_dir(),"sigmond_spectrum_log.xml"), #actually creating this
                self.other_params['precompute'],
                None,
            )

            this_fit_config = {}
            params_to_update = ['sim_fit', 'priors']
            if 'tmin_min' in plot:
                this_fit_config['tmin'] = i
                this_fit_config['tmax'] = this_fit_input['tmax']
                params_to_update.append('tmax')
            else: 
                this_fit_config['tmin'] = this_fit_input['tmin']
                this_fit_config['tmax'] = i
                params_to_update.append('tmin')
            for config in ['tmax', 'sim_fit', 'priors']:
                if config in plot:
                    this_fit_config[config] = plot[config]
            this_fit_config['model'] = fit_info.FitModel(plot['model'])
            if 'ratio' in plot:
                this_fit_config['ratio'] = plot['ratio']
                if plot['ratio']:
                    this_fit_config["non_interacting_level"] = this_fit_input["non_interacting_level"]
                    this_fit_config["non_interacting_operators"] = this_fit_input["non_interacting_operators"]

            for param, setting in self.default_fit_params.items():
                if param not in this_fit_config:
                    this_fit_config[param] = setting
            if this_fit_config!=this_fit_input:
                try:
                    if not self.other_params['minimizer_info']['minimizer']=='lmder':
                        nsamplings = self.project_handler.project_info.sampling_info.getNumberOfReSamplings(self.project_handler.project_info.bins_info)
                        this_fit_info, these_fit_results, chisqr, qual, dof = sigmond_util.scipy_fit(intop, self.other_params['minimizer_info'], this_fit_config, self.mcobs_handler, 
                                                self.project_handler.subtract_vev, self.project_handler.hermitian, self.ensemble_info.getLatticeTimeExtent(), 
                                                self.project_handler.nodes, nsamplings, False, sh_priors, scat_info[:])
                    else:
                        this_fit_info, these_fit_results, chisqr, qual, dof = sigmond_util.sigmond_fit(task_input, intop, self.other_params['minimizer_info'], this_fit_config, self.mcobs_handler, 
                                            self.project_handler.project_info.sampling_info.getSamplingMode(), self.project_handler.subtract_vev, "NA", True, sh_priors, scat_info[:])

                    if results[channel][intop]["fits"][model]["info"]==None:
                        results[channel][intop]["fits"][model]["info"] = this_fit_info
                    results[channel][intop]["fits"][model][i] = {
                        "estimates": these_fit_results, 
                        "chisqrdof": float(chisqr), 
                        "qual": float(qual),
                        "dof": int(dof)
                    }
                    #compute relevant info, but we don't care about saving the tmin fit samplings
                    tfitenergy_obs_info = sigmond.MCObsInfo("dummy", this_fit_info.energy_index)
                    delab_obs_info = sigmond.MCObsInfo("dummy", this_fit_info.num_params)
                    elab_obs_info = sigmond.MCObsInfo("dummy", this_fit_info.num_params+1)
                    ecm_obs_info = sigmond.MCObsInfo("dummy", this_fit_info.num_params+2)

                    if "non_interacting_level" in this_fit_input:
                        this_ni_level = this_fit_input["non_interacting_level"]
                        if this_fit_info.sim_fit:
                            if scat_info[0]!=scat_info_initial:
                                self.other_params['non_interacting_levels'][str(channel)][intop.level].reverse()
                            this_ni_level = get_sim_ni_level_tmin(this_fit_input["non_interacting_level"],this_fit_info,scat_info)

                    if this_fit_info.ratio: 
                        #compute ecm and elab
                        delab_obs_info = tfitenergy_obs_info
                        Nx = self.ensemble_info.getLatticeXExtent()
                        ni_levels = [(sh,mom*6.2831853071795864770*6.2831853071795864770/Nx/Nx) for sh,mom in this_ni_level]
                        sigmond.doReconstructEnergyBySamplings(self.mcobs_handler,delab_obs_info,ni_levels,elab_obs_info)
                        results[channel][intop]["fits"][model][i]["elab"] = self.mcobs_handler.getEstimate(elab_obs_info)
                        results[channel][intop]["fits"][model][i]["dElab"] = these_fit_results[this_fit_info.energy_index]
                    else:
                        results[channel][intop]["fits"][model][i]["elab"] = these_fit_results[this_fit_info.energy_index]
                        elab_obs_info = tfitenergy_obs_info
                        if "non_interacting_level" in this_fit_input:
                            #compute delab
                            Nx = self.ensemble_info.getLatticeXExtent()
                            ni_levels = [(sh,mom*6.2831853071795864770*6.2831853071795864770/Nx/Nx) for sh,mom in this_ni_level]
                            sigmond.doEnergyDifferenceBySamplings(self.mcobs_handler,elab_obs_info,ni_levels,delab_obs_info)
                            results[channel][intop]["fits"][model][i]["dElab"] = self.mcobs_handler.getEstimate(delab_obs_info)

                            #used correlated sim fit to construct the shift, but then use rest mass fit
                                #and dispersion relation to shift back to elab #overwriting original elab
                            if this_fit_info.sim_fit:
                                ni_levels = [(sh,mom*6.2831853071795864770*6.2831853071795864770/Nx/Nx) for sh,mom in this_fit_input["non_interacting_level"]]
                                sigmond.doReconstructEnergyBySamplings(self.mcobs_handler,delab_obs_info,ni_levels,elab_obs_info)
                                results[channel][intop]["fits"][model][i]["elab"]= self.mcobs_handler.getEstimate(elab_obs_info)

                    # if intop.channel.psq==0:
                    #     results[channel][intop]["fits"][model][i]["ecm"] = results[channel][intop]["fits"][model][i]["elab"]
                    # else:
                    #     sigmond.doBoostBySamplings(self.mcobs_handler,elab_obs_info,intop.channel.psq,ecm_obs_info)
                    #     results[channel][intop]["fits"][model][i]["ecm"] = self.mcobs_handler.getEstimate(ecm_obs_info)
                except ValueError as err:
                    # print(f"ValueError: Tmin fit {i} for model {model} failed: {err}")
                    results[channel][intop]["fits"][model][i] = None
                except RuntimeError as err:
                    # print(f"RuntimeError: Tmin fit {i} for model {model} failed: {err}")
                    results[channel][intop]["fits"][model][i] = None
        
        if "sim_fit" in plot:
            if plot["sim_fit"]:
                plot['model'] = "2-exp" #generalize
                plot['priors'] = {}

    #use information about single hadrons and correlator data to set up priors for simultaneous fits
    def set_up_sim_fit(self, plot, model, scat_info, sh_priors, channel, intop):
        #setup priors
        pivot_type = sigmond_util.get_pivot_type(self.other_params["pivot_file"])
        if pivot_type==None:
            logging.warning("Need pivot information in order to do Conspiracy fits")
            return False
        if str(channel) not in self.other_params['non_interacting_levels']:
            logging.warning("Need non interacting level defined in order to do Conspiracy fits")
            return False
        if len(self.other_params['non_interacting_levels'][str(channel)])<=intop.level:
            logging.warning("Need non interacting level defined in order to do Conspiracy fits")
            return False
        pivoter = sigmond_util.setup_pivoter(pivot_type, self.other_params["pivot_file"], channel, self.mcobs_handler)
        corr = sigmond.CorrelatorAtTimeInfo(intop.operator_info,intop.operator_info,pivoter.getTauZ(),self.project_handler.hermitian,self.project_handler.subtract_vev)
        corrplus1 = sigmond.CorrelatorAtTimeInfo(intop.operator_info,intop.operator_info,pivoter.getTauZ()+self.project_handler.time_separation,
                                                 self.project_handler.hermitian,self.project_handler.subtract_vev)
        self.mcobs_handler.setSamplingBegin()
        ecalc = sigmond.EffectiveEnergyCalculator( self.project_handler.time_separation, self.ensemble_info.getLatticeTimeExtent(),
                                                  self.project_handler.effective_energy_type)
        corrmean_at_tZ = self.mcobs_handler.getCurrentSamplingValue(sigmond.MCObsInfo(corr,sigmond.ComplexArg.RealPart))
        corrmean_at_tZplus1 = self.mcobs_handler.getCurrentSamplingValue(sigmond.MCObsInfo(corrplus1,sigmond.ComplexArg.RealPart))
        energy_init = ecalc.calculate(pivoter.getTauZ(),corrmean_at_tZ,corrmean_at_tZplus1,0.0)
        amp_init = corrmean_at_tZ/np.exp(-energy_init*pivoter.getTauZ())
        non_interacting_level = OrderedSet(self.other_params['non_interacting_levels'][str(channel)][intop.level])
        for level in non_interacting_level:
            hadron, mom = level.split("(")
            mom = int(mom[:-1])
            shop = operator.Operator(self.other_params['single_hadrons'][hadron][mom])
            sh_fit_info = self.single_hadron_results[shop.channel][shop]["info"]
            scat_info.append(sh_fit_info)
            sh_fit_est = self.single_hadron_results[shop.channel][shop]["estimates"]
            sh_priors[sh_fit_info.obs_name] = {}
            for sh_param, est in zip(sh_fit_info.param_names, sh_fit_est):
                sh_priors[sh_fit_info.obs_name][sh_param] = {"Mean": est.getFullEstimate(), "Error": 4.0*est.getSymmetricError()}
        if len(non_interacting_level)==1 and model=="2-exp-sim":
            plot['model'] = "2-exp-deg-cons"
        elif len(non_interacting_level)==2 and model=="2-exp-sim":
            plot['model'] = "2-exp-cons"
        else:
            logging.error("This fit type is not supported for simultaneous fits.")
        plot["priors"] = {
            "FirstEnergy": {"Mean": energy_init, "Error": 0.1*energy_init},
            "FirstAmplitude": {"Mean": amp_init, "Error": 0.5*amp_init},
        }
        for param in fit_info.FitInfo.PARAMETERS[fit_info.FitModel(plot["model"])]:
            if "Ratio" in param:
                plot["priors"][param] = {"Mean": 1.0, "Error": 0.75}
            if "delta" in param:
                plot["priors"][param] = {"Mean": 0.0, "Error": 0.015}

        return True


    
def get_sim_ni_level(ni_level, central_fit_obs_name, scat_info):
    this_ni_level = ni_level[:]
    if len(scat_info)==2:
        for i,scat in enumerate(scat_info):
            new_obs_name = central_fit_obs_name+"-"+scat.obs_name
            this_ni_level[i] = (sigmond.MCObsInfo(new_obs_name,scat.obs_id(scat_info[0].energy_index)),0)
    elif len(scat_info)==1:
        for i in range(len(this_ni_level)):
            new_obs_name = central_fit_obs_name+"-"+scat_info[0].obs_name
            this_ni_level[i] = (sigmond.MCObsInfo(new_obs_name,scat_info[0].obs_id(scat_info[0].energy_index)),0)
    return this_ni_level

def get_sim_ni_level_tmin(ni_level, this_fit_info, scat_info):
    this_ni_level = ni_level[:]
    if len(scat_info)==2:
        for i,scat_info in enumerate(scat_info):
            this_ni_level[i] = (sigmond.MCObsInfo("dummy",this_fit_info.num_params+i*scat_info.num_params),0)
    elif len(scat_info)==1:
        for i in range(len(this_ni_level)):
            this_ni_level[i] = (sigmond.MCObsInfo("dummy",this_fit_info.num_params),0)
    return this_ni_level
